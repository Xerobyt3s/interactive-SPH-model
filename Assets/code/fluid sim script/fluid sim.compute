#pragma kernel ExternalForces
#pragma kernel UpdateSpatialLookUp
#pragma kernel CalculateDensities
#pragma kernel CalculatePressureForce
#pragma kernel CalculateViscosity
#pragma kernel UpdateParticlePosition

#include "./SpatialHash.hlsl" 

RWStructuredBuffer<float3> positions;
RWStructuredBuffer<float3> predictedPositions;
RWStructuredBuffer<float3> velocities;
RWStructuredBuffer<float2> densities;

//used in my neighbour search algorithm
RWStructuredBuffer<uint3> spacialLookUp;
RWStructuredBuffer<int> startIndecies;


//constants for the simulation
const uint particleCount;
const float gravity;
const float deltaTime;
const float collisionDampening;
const float smoothingRadius;
const float targetDensity;
const float pressureMultiplier;
const float nearPressureMultiplier;
const float viscosityMultiplier;
const float3 boundsSize;

const float2 mousePosition;
const float mouseInputStrength;
const float mouseRadius;

const float4x4 localToWorld;
const float4x4 worldToLocal;

const float Poly6ScalingFactor;
const float SpikyPow3ScalingFactor;
const float SpikyPow2ScalingFactor;
const float SpikyPow3DerivativeScalingFactor;
const float SpikyPow2DerivativeScalingFactor;

//polynomial functions
float DensityKernel(float dst, float radius)
{
	if (dst < radius)
	{
		float v = radius - dst;
		return v * v * SpikyPow2ScalingFactor;
	}
	return 0;
}

float NearDensityKernel(float dst, float radius)
{
	if (dst < radius)
	{
		float v = radius - dst;
		return v * v * v * SpikyPow3ScalingFactor;
	}
	return 0;
}

float DensityDerivative(float dst, float radius)
{
	if (dst <= radius)
	{
		float v = radius - dst;
		return -v * SpikyPow2DerivativeScalingFactor;
	}
	return 0;
}

float NearDensityDerivative(float dst, float radius)
{
	if (dst <= radius)
	{
		float v = radius - dst;
		return -v * v * SpikyPow3DerivativeScalingFactor;
	}
	return 0;
}

float ViscosityKernel(float dst, float radius)
{
	if (dst < radius)
	{
		float v = radius * radius - dst * dst;
		return v * v * v * Poly6ScalingFactor;
	}
	return 0;
}

// Update the spacial lookup array to reflect the current positions of the particles
[numthreads(64, 1, 1)]
void UpdateSpatialLookUp (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= particleCount) return;

	// Reset offsets
	startIndecies[id.x] = particleCount;
    
	// Update index buffer
	uint index = id.x;
	int3 cell = GetCell(predictedPositions[index], smoothingRadius);
	uint hash = HashCell(cell);
	uint key = KeyFromHash(hash, particleCount);
	spacialLookUp[id.x] = uint3(index, hash, key);
}


float2 CalculateDensity(float3 pos)
{
	int3 originCell = GetCell(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;
	float density = 0;
	float nearDensity = 0;

	// Neighbour search
	for (int i = 0; i < 27; i++)
	{
		uint hash = HashCell(originCell + offsets[i]);
		uint key = KeyFromHash(hash, particleCount);
		uint currIndex = startIndecies[key];

		while (currIndex < particleCount)
		{
			uint3 indexData = spacialLookUp[currIndex];
			currIndex++;
			// Exit if no longer looking at correct bin
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			float3 neighbourPos = predictedPositions[neighbourIndex];
			float3 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate density and near density
			float dst = sqrt(sqrDstToNeighbour);
			density += DensityKernel(dst, smoothingRadius);
			nearDensity += NearDensityKernel(dst, smoothingRadius);
		}
	}

	return float2(density, nearDensity);
}

[numthreads(64, 1, 1)]
void CalculateDensities (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= particleCount) return;

	float3 position = predictedPositions[id.x];
	densities[id.x] = CalculateDensity(position);
}

float CalculatePressure(float density)
{
    return (density - targetDensity) * pressureMultiplier;
}

float CalculateNearPressure(float nearDensity)
{
    return nearPressureMultiplier * nearDensity;
}

[numthreads(64, 1, 1)]
void CalculatePressureForce (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= particleCount) return;

	float density = densities[id.x][0];
	float densityNear = densities[id.x][1];
	float pressure = CalculatePressure(density);
	float nearPressure = CalculateNearPressure(densityNear);
	float3 pressureForce = 0;
	
	float3 pos = predictedPositions[id.x];
	int3 originCell = GetCell(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;

	// Neighbour search
	for (int i = 0; i < 27; i ++)
	{
		uint hash = HashCell(originCell + offsets[i]);
		uint key = KeyFromHash(hash, particleCount);
		uint currIndex = startIndecies[key];

		while (currIndex < particleCount)
		{
			uint3 indexData = spacialLookUp[currIndex];
			currIndex ++;
			// Exit if no longer looking at correct bin
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			// Skip if looking at self
			if (neighbourIndex == id.x) continue;

			float3 neighbourPos = predictedPositions[neighbourIndex];
			float3 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate pressure force
			float dst = sqrt(sqrDstToNeighbour);
			float3 dirToNeighbour = dst > 0 ? offsetToNeighbour / dst : float3(0, 1, 0);

			float neighbourDensity = densities[neighbourIndex][0];
			float neighbourNearDensity = densities[neighbourIndex][1];
			float neighbourPressure = CalculatePressure(neighbourDensity);
			float neighbourNearPressure = CalculateNearPressure(neighbourNearDensity);

			float sharedPressure = (pressure + neighbourPressure) * 0.5;
			float sharedNearPressure = (nearPressure + neighbourNearPressure) * 0.5;

			pressureForce += dirToNeighbour * DensityDerivative(dst, smoothingRadius) * sharedPressure / neighbourDensity;
			pressureForce += dirToNeighbour * NearDensityDerivative(dst, smoothingRadius) * sharedNearPressure / neighbourNearDensity;
		}
	}

	float3 acceleration = pressureForce / density;
	velocities[id.x] += acceleration * deltaTime;//
}

[numthreads(64, 1, 1)]
void CalculateViscosity (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= particleCount) return;

    float3 force = 0;

    float3 position = predictedPositions[id.x];

    //find the cell cords of the point
    int3 cell = GetCell(position, smoothingRadius);
    float radiusSquared = smoothingRadius * smoothingRadius;

    for (int i = 0; i < 27; i ++)
    {
        uint hash = HashCell(cell + offsets[i]);
        uint cellKey = KeyFromHash(hash, particleCount);
        int searchIndex = startIndecies[cellKey];

        //loop over all particles in the cell
        while (searchIndex < particleCount)
        {
            searchIndex++;

            //break if the cell key changes
            if (spacialLookUp[searchIndex][2] != cellKey) break;

            if (spacialLookUp[searchIndex][1] != hash)    continue;

            int NeighbourParticleIndex = spacialLookUp[searchIndex][0];

            if (NeighbourParticleIndex == id.x) continue;

            float3 offsetToNeighbour = predictedPositions[NeighbourParticleIndex] - position;
            float distanceSquared = dot(offsetToNeighbour, offsetToNeighbour); 

            //check if the particle is in the radius
            if (distanceSquared > radiusSquared) continue;
                
            //calculate the force
            force += (velocities[NeighbourParticleIndex] - velocities[id.x]) * ViscosityKernel(sqrt(distanceSquared), smoothingRadius);
        }
    }
    velocities[id.x] += force * viscosityMultiplier * deltaTime;
}

void CheckCollisions(uint particleIndex)
{
    // Transform position/velocity to the local space of the bounding box (scale not included)
	float3 posLocal = mul(worldToLocal, float4(positions[particleIndex], 1)).xyz;
	float3 velocityLocal = mul(worldToLocal, float4(velocities[particleIndex], 0)).xyz;

	// Calculate distance from box on each axis (negative values are inside box)
	const float3 halfSize = 0.5;
	const float3 edgeDst = halfSize - abs(posLocal);

	// Resolve collisions
	if (edgeDst.x <= 0)
	{
		posLocal.x = halfSize.x * sign(posLocal.x);
		velocityLocal.x *= -1 * collisionDampening;
	}
	if (edgeDst.y <= 0)
	{
		posLocal.y = halfSize.y * sign(posLocal.y);
		velocityLocal.y *= -1 * collisionDampening;
	}
	if (edgeDst.z <= 0)
	{
		posLocal.z = halfSize.z * sign(posLocal.z);
		velocityLocal.z *= -1 * collisionDampening;
	}

	// Transform resolved position/velocity back to world space
	positions[particleIndex] = mul(localToWorld, float4(posLocal, 1)).xyz;
	velocities[particleIndex] = mul(localToWorld, float4(velocityLocal, 0)).xyz;
}

[numthreads(64, 1, 1)]
void ExternalForces(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= particleCount) return;

	// apply outside forces such as gravity and the mouse interaction
	velocities[id.x] += float3(0, -gravity, 0) * deltaTime;

	// update predicted positions
	const float predictionFactor = 1 / 120.0;
	predictedPositions[id.x] = positions[id.x] + velocities[id.x] * predictionFactor;
}

// Update the positions of the particles
[numthreads(64, 1, 1)]
void UpdateParticlePosition(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= particleCount) return;

	positions[id.x] += velocities[id.x] * deltaTime;
	CheckCollisions(id.x);
}